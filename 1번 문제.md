# **_Lock 활용_**

## **_배경_**

일반적으로 row를 업데이트하기 위해서는 해당 row를 우선 조회를 해옵니다. 또한 DB에서의 하나의 작업을 할 때에 트랜잭션으로 묶어서 행합니다. 즉, 데이터를 조회하고 업데이트를 하는 하나의 작업은 하나의 트랜잭션에서 행하게 됩니다.

만약, 동시에 같은 row를 업데이트를 하고자 한다면 2개의 트랜잭션이 같은 row를 조회해 옵니다. 그리고 각각의 트랜잭션은 조회해 온 row를 대상으로 데이터를 갱신합니다. 바로 여기서 문제가 발생합니다.  
해당 예시는 프로젝트를 진행하면서 부딪힌 예시로, 게시글을 조회할 때 조회수의 값을 +1을 해주는 비즈니스 로직이 존재했습니다. 이 때, 동시에 게시글을 조회하게 된다면 조회수의 값이 +2가 아닌 +1이 되어버리는 상황이 발생했습니다.  
그 이유는, 조회수가 0일 때의 게시글 row가 있는데 2개의 요청에 의한 2개의 트랜잭션이 동시에 조회수 0인 게시글 row를 가져오고, 각 트랜잭션은 0 -> 1 값으로 증가시키는 갱신 작업을 할 뿐이었습니다. 결국 조회수는 1만 증가시키게 되는 문제를 갖고 있었습니다.

그래서 이러한 동시성 문제를 해결하기 위해서 찾아보다가 Lock을 활용한 방법을 알았고 이를 프로젝트에 도입했습니다.

</br>

## **_도입_**

**_(JPA를 기반으로 하는 동시성 문제 해결 방안입니다.)_**

DB에서 select for update 구문을 사용하면, 조회해온 row에 대해서 베타락을 걸어둡니다. 그러면 해당 row는 갱신하고 트랜잭션이 커밋이 되기전까지는 다른 트랜잭션은 해당 row를 건드릴 수 없습니다.  
이러면 위에서 말한 예시의 문제를 해결할 수 있습니다. 하나의 트랜잭션이 row를 조회하는 순간 이후의 트랜잭션은 기다려야 하는 상황이 발생하고 그러면 정상적으로 하나씩 row를 갱신하고, 갱신된 row를 조회하고 다시 갱신하고... 즉, 동시성 문제를 해결할 수 있게 됩니다.

JPA에서는 이러한 문제를 해결햊 줄 수 있는 방안을 제공해줍니다. "비관적 락"과 "낙관적 락"이 존재하며, 위에서 말한 select for update구문을 통해 베타락을 사용하는 방안은 "비관적 락"을 사용해야 합니다.

```java
@Lock(LockModeType.PESSIMISTIC_WRITE)
@Query("SELECT p FROM Post p WHERE p.id = :id")
Optional<Post> findByIdForUpdate(Long id);
```

위와 같이 데이터를 조회해 오는 쿼리에 대해 @Lock 어노테이션의 PESSIMISTIC_WRITE을 정의하면, 위에서 말한대로 동작하게 됩니다.

이를 통해 JPA에서의 동시성 문제를 해결할 수 있습니다.

</br>

## **_문제점_**

위와 같이 베타락을 통해서 해결하는 방법은 성능이슈가 존재합니다. 하나의 트랜잭션이 커밋되기 전까지는 다른 트랜잭션은 대기해야 하는 상황이 발생하여 소요 시간이 증가하게 됩니다.

</br>

## **_다른 방법_**

위는 JPA를 사용하여 베타락을 걸어서 해결하는 방법입니다. 저는 해당 방법 밖에 몰라서 다른 방법을 찾아 봤습니다.  
그 결과로 메시지 큐를 통해서 해결하는 방법을 알게 되었습니다.  
메시지 큐 방식과 함꼐 Redis를 활용하는 방법, Kafka를 활용하는 방법 등 매우 다양하게 메시지 큐와 함께 사용해서 해결할 수 있다는 것을 알 수 있었습니다.
